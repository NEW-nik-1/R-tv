<!DOCTYPE html> <html lang="ru"> <head> <meta charset="UTF-8" /> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>Редактор с VK Bridge и оптимизированным перетаскиванием</title> <style> body { font-family: Arial,sans-serif; margin:8px; display:flex; flex-direction:column; align-items:center; gap:8px; user-select:none; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; } #canvasWrap { background:#b0b0b0; border-radius:6px; padding:8px; box-shadow:0 0 4px #999; } canvas { background:#222; cursor:grab; width:960px; height:384px; user-select:none; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; -webkit-touch-callout:none; -webkit-tap-highlight-color: transparent; -webkit-user-drag:none; display:block; border-radius:0px; } #controls { width:960px; display:grid; grid-template-columns:repeat(auto-fit,minmax(150px,1fr)); gap:12px; } label { display:block; font-size:13px; margin-bottom:4px; } input, select, button { width:100%; padding:6px; font-size:13px; box-sizing:border-box; } button { cursor:pointer; border-radius:4px; border:1px solid #bbb; background:#fff; user-select:none; } button.active { background:#2b83ff; color:#fff; } .flex-row { display:flex; gap:8px; align-items:center; } #controls .flex-row > button { width: auto; min-width: 40px; font-weight: bold; } </style> </head> <body> <h2>Редактор картинок и текста с VK Bridge и оптимизацией</h2> <div class="flex-row" style="gap:16px;"> <label for="bgFile" style="flex:1 0 120px;">Фон</label> <input type="file" id="bgFile" accept="image/*" style="flex:2 0 200px;" /> <label for="addImgFile" style="flex:1 0 140px;">Добавить картинку</label> <input type="file" id="addImgFile" accept="image/*" style="flex:2 0 200px;" /> </div> <div id="canvasWrap"> <canvas id="canvas" width="1920" height="768"></canvas> </div> <div id="controls"> <div><label for="posX">X</label><input type="number" id="posX" /></div> <div><label for="posY">Y</label><input type="number" id="posY" /></div> <div style="grid-column:1/-1;"><label for="textValue">Текст</label><input type="text" id="textValue" /></div> <div style="grid-column:1/-1;"> <label for="fontSelect">Шрифт</label> <select id="fontSelect"> <option>Arial</option> <option>Roboto</option> <option>"Times New Roman"</option> <option>Georgia</option> </select> </div> <div><label for="fontSizeRange">Размер текста</label><input type="range" id="fontSizeRange" min="10" max="200" value="40" /></div> <div><label for="rotateText">Поворот текста, °</label><input type="range" id="rotateText" min="0" max="360" value="0" /></div> <div class="flex-row" style="grid-column:1/-1; justify-content:flex-start;"> <button id="boldBtn" title="Жирный (B)">B</button> <button id="italicBtn" title="Курсив (/)">/</button> <button id="uppercaseBtn" title="Прописные буквы (ABC)">ABC</button> </div> <div><label for="colorText">Цвет текста</label><input type="color" id="colorText" value="#ffffff" /></div> <div><label for="strokeColor">Цвет обводки</label><input type="color" id="strokeColor" value="#000000" /></div> <div><label for="strokeWidth">Толщина обводки</label><input type="range" id="strokeWidth" min="0" max="20" value="0" /></div> <div class="flex-row" style="gap:8px;"> <label for="bgRadius" style="margin-bottom:0;">Скруглить фон</label> <input type="checkbox" id="bgRadius" /> </div> <div><label for="imageScaleRange">Масштаб картинки</label><input type="range" id="imageScaleRange" min="0.1" max="3" step="0.01" value="1" disabled /></div> <div class="flex-row" style="grid-column:1/-1; gap:8px;"> <button id="addTextBtn">+ Текст</button> <button id="deleteTextBtn">- Текст</button> <button id="saveJPG">Сохранить JPEG</button> <button id="savePNG">Сохранить PNG</button> </div> </div> <script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script> <script> (async () => { try { await vkBridge.send('VKWebAppInit'); console.log('VK Bridge инициализирован успешно'); } catch (e) { console.warn('VK Bridge инициализация не удалась или недоступна', e); } })(); </script> <script> const canvas = document.getElementById('canvas'); const ctx = canvas.getContext('2d'); let bgImage = null; let images = []; let objects = []; let selectedType = null; // 'text' или 'image' let selectedIndex = -1; let dragging = false; let dragOffsetX = 0, dragOffsetY = 0; let needsRedraw = false; class TextObject { constructor(opts = {}) { this.type = 'text'; this.x = opts.x || 100; this.y = opts.y || 100; this.text = opts.text || 'текст'; this.fontFamily = opts.fontFamily || 'Arial'; this.fontSize = opts.fontSize || 40; this.bold = false; this.italic = false; this.uppercase = false; this.color = '#ffffff'; this.strokeColor = '#000000'; this.strokeWidth = 0; this.rotation = 0; } } class ImageObject { constructor(img, x = 0, y = 0, scale = 1) { this.type = 'image'; this.img = img; this.x = x; this.y = y; this.width = img.width; this.height = img.height; this.scale = scale; this.rotation = 0; } } function createThumbnail(image, maxSize = 300) { const tCanvas = document.createElement('canvas'); const tCtx = tCanvas.getContext('2d'); let scale = 1; if (image.width > image.height) { scale = maxSize / image.width; tCanvas.width = maxSize; tCanvas.height = image.height * scale; } else { scale = maxSize / image.height; tCanvas.height = maxSize; tCanvas.width = image.width * scale; } tCtx.drawImage(image, 0, 0, tCanvas.width, tCanvas.height); const thumb = new Image(); thumb.src = tCanvas.toDataURL(); return thumb; } function measureText(o) { ctx.save(); ctx.font = (o.italic ? 'italic ' : '') + (o.bold ? 'bold ' : '') + o.fontSize + 'px ' + o.fontFamily; const text = o.uppercase ? o.text.toUpperCase() : o.text; const metrics = ctx.measureText(text); ctx.restore(); return metrics.width; } function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.save(); if (bgImage) { if (document.getElementById('bgRadius').checked) { let r = 30; ctx.beginPath(); ctx.moveTo(r, 0); ctx.lineTo(canvas.width - r, 0); ctx.quadraticCurveTo(canvas.width, 0, canvas.width, r); ctx.lineTo(canvas.width, canvas.height - r); ctx.quadraticCurveTo(canvas.width, canvas.height, canvas.width - r, canvas.height); ctx.lineTo(r, canvas.height); ctx.quadraticCurveTo(0, canvas.height, 0, canvas.height - r); ctx.lineTo(0, r); ctx.quadraticCurveTo(0, 0, r, 0); ctx.closePath(); ctx.clip(); } ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height); } else { ctx.fillStyle = '#222'; ctx.fillRect(0, 0, canvas.width, canvas.height); } ctx.restore(); images.forEach(imgObj => { ctx.save(); ctx.translate(imgObj.x + imgObj.width * imgObj.scale / 2, imgObj.y + imgObj.height * imgObj.scale / 2); ctx.rotate(imgObj.rotation * Math.PI / 180); ctx.drawImage(imgObj.img, -imgObj.width * imgObj.scale / 2, -imgObj.height * imgObj.scale / 2, imgObj.width * imgObj.scale, imgObj.height * imgObj.scale); ctx.restore(); }); objects.forEach(o => { ctx.save(); ctx.translate(o.x, o.y); ctx.rotate(o.rotation * Math.PI / 180); ctx.font = (o.italic ? 'italic ' : '') + (o.bold ? 'bold ' : '') + o.fontSize + 'px ' + o.fontFamily; ctx.textBaseline = 'top'; const displayText = o.uppercase ? o.text.toUpperCase() : o.text; if (o.strokeWidth > 0) { ctx.lineWidth = o.strokeWidth; ctx.strokeStyle = o.strokeColor; ctx.strokeText(displayText, 0, 0); } ctx.fillStyle = o.color; ctx.fillText(displayText, 0, 0); ctx.restore(); }); if (selectedType === 'text' && selectedIndex >= 0) { const o = objects[selectedIndex]; ctx.save(); ctx.font = (o.italic ? 'italic ' : '') + (o.bold ? 'bold ' : '') + o.fontSize + 'px ' + o.fontFamily; const w = measureText(o); const h = o.fontSize; ctx.strokeStyle = 'yellow'; ctx.lineWidth = 2; ctx.beginPath(); ctx.rect(o.x - 2, o.y - 2, w + 4, h + 4); ctx.stroke(); ctx.restore(); } else if (selectedType === 'image' && selectedIndex >= 0) { const imgObj = images[selectedIndex]; ctx.save(); ctx.strokeStyle = 'yellow'; ctx.lineWidth = 2; ctx.beginPath(); ctx.rect(imgObj.x - 2, imgObj.y - 2, imgObj.width * imgObj.scale + 4, imgObj.height * imgObj.scale + 4); ctx.stroke(); ctx.restore(); } updateControls(); } function updateControls() { if (selectedType === 'text' && selectedIndex >= 0) { const o = objects[selectedIndex]; document.getElementById('posX').value = Math.round(o.x); document.getElementById('posY').value = Math.round(o.y); document.getElementById('textValue').value = o.text; document.getElementById('fontSelect').value = o.fontFamily; document.getElementById('fontSizeRange').value = o.fontSize; document.getElementById('rotateText').value = o.rotation; document.getElementById('boldBtn').classList.toggle('active', o.bold); document.getElementById('italicBtn').classList.toggle('active', o.italic); document.getElementById('uppercaseBtn').classList.toggle('active', o.uppercase); document.getElementById('colorText').value = o.color; document.getElementById('strokeColor').value = o.strokeColor; document.getElementById('strokeWidth').value = o.strokeWidth; document.getElementById('imageScaleRange').disabled = true; } else if (selectedType === 'image' && selectedIndex >= 0) { const imgObj = images[selectedIndex]; document.getElementById('posX').value = Math.round(imgObj.x); document.getElementById('posY').value = Math.round(imgObj.y); document.getElementById('imageScaleRange').value = imgObj.scale.toFixed(2); document.getElementById('imageScaleRange').disabled = false; document.getElementById('textValue').value = ''; document.getElementById('fontSelect').value = 'Arial'; document.getElementById('fontSizeRange').value = 40; document.getElementById('rotateText').value = 0; document.getElementById('boldBtn').classList.remove('active'); document.getElementById('italicBtn').classList.remove('active'); document.getElementById('uppercaseBtn').classList.remove('active'); document.getElementById('colorText').value = '#ffffff'; document.getElementById('strokeColor').value = '#000000'; document.getElementById('strokeWidth').value = 0; } else { document.getElementById('posX').value = ''; document.getElementById('posY').value = ''; document.getElementById('textValue').value = ''; document.getElementById('fontSelect').value = 'Arial'; document.getElementById('fontSizeRange').value = 40; document.getElementById('rotateText').value = 0; document.getElementById('boldBtn').classList.remove('active'); document.getElementById('italicBtn').classList.remove('active'); document.getElementById('uppercaseBtn').classList.remove('active'); document.getElementById('colorText').value = '#ffffff'; document.getElementById('strokeColor').value = '#000000'; document.getElementById('strokeWidth').value = 0; document.getElementById('imageScaleRange').value = 1; document.getElementById('imageScaleRange').disabled = true; } } function updateSelected() { if (selectedType === 'text' && selectedIndex >= 0) { const o = objects[selectedIndex]; const xVal = parseInt(document.getElementById('posX').value); const yVal = parseInt(document.getElementById('posY').value); if (!isNaN(xVal)) o.x = xVal; if (!isNaN(yVal)) o.y = yVal; const textVal = document.getElementById('textValue').value; if (textVal !== '') o.text = textVal; o.fontFamily = document.getElementById('fontSelect').value; const fSize = parseInt(document.getElementById('fontSizeRange').value); if (!isNaN(fSize)) o.fontSize = fSize; const rotation = parseInt(document.getElementById('rotateText').value); if (!isNaN(rotation)) o.rotation = rotation; o.color = document.getElementById('colorText').value; o.strokeColor = document.getElementById('strokeColor').value; const strokeWidth = parseInt(document.getElementById('strokeWidth').value); o.strokeWidth = isNaN(strokeWidth) ? 0 : strokeWidth; needsRedraw = true; } else if (selectedType === 'image' && selectedIndex >= 0) { const imgObj = images[selectedIndex]; const xVal = parseInt(document.getElementById('posX').value); const yVal = parseInt(document.getElementById('posY').value); if (!isNaN(xVal)) imgObj.x = xVal; if (!isNaN(yVal)) imgObj.y = yVal; const scaleVal = parseFloat(document.getElementById('imageScaleRange').value); if (!isNaN(scaleVal) && scaleVal > 0) imgObj.scale = scaleVal; needsRedraw = true; } requestAnimationFrame(drawIfNeeded); } document.getElementById('addTextBtn').onclick = () => { objects.push(new TextObject({text: 'Новый текст'})); selectedType = 'text'; selectedIndex = objects.length - 1; needsRedraw = true; requestAnimationFrame(drawIfNeeded); }; document.getElementById('deleteTextBtn').onclick = () => { if (selectedType === 'text' && selectedIndex >= 0) { objects.splice(selectedIndex, 1); selectedType = null; selectedIndex = -1; needsRedraw = true; requestAnimationFrame(drawIfNeeded); } }; document.getElementById('boldBtn').onclick = () => { if (selectedType === 'text' && selectedIndex >= 0) { objects[selectedIndex].bold = !objects[selectedIndex].bold; document.getElementById('boldBtn').classList.toggle('active', objects[selectedIndex].bold); needsRedraw = true; requestAnimationFrame(drawIfNeeded); } }; document.getElementById('italicBtn').onclick = () => { if (selectedType === 'text' && selectedIndex >= 0) { objects[selectedIndex].italic = !objects[selectedIndex].italic; document.getElementById('italicBtn').classList.toggle('active', objects[selectedIndex].italic); needsRedraw = true; requestAnimationFrame(drawIfNeeded); } }; document.getElementById('uppercaseBtn').onclick = () => { if (selectedType === 'text' && selectedIndex >= 0) { objects[selectedIndex].uppercase = !objects[selectedIndex].uppercase; document.getElementById('uppercaseBtn').classList.toggle('active', objects[selectedIndex].uppercase); needsRedraw = true; requestAnimationFrame(drawIfNeeded); } }; [ 'posX','posY','textValue','fontSelect','fontSizeRange','rotateText', 'colorText','strokeColor','strokeWidth','bgRadius','imageScaleRange' ].forEach(id => document.getElementById(id).addEventListener('input', () => { if(id === 'bgRadius') { needsRedraw = true; requestAnimationFrame(drawIfNeeded); } else updateSelected(); })); document.getElementById('bgFile').addEventListener('change', (e) => { const f = e.target.files; if (!f) return; const img = new Image(); img.onload = () => { bgImage = img; needsRedraw = true; requestAnimationFrame(drawIfNeeded); }; img.src = URL.createObjectURL(f); }); document.getElementById('addImgFile').addEventListener('change', (e) => { const f = e.target.files; if (!f) return; const img = new Image(); img.onload = () => { const thumb = createThumbnail(img, 300); thumb.onload = () => { images.push(new ImageObject(thumb, 50, 50, 1)); selectedType = 'image'; selectedIndex = images.length - 1; needsRedraw = true; requestAnimationFrame(drawIfNeeded); }; }; img.src = URL.createObjectURL(f); }); function isPointInText(o, x, y) { const w = measureText(o); const h = o.fontSize; return (x >= o.x && x <= o.x + w && y >= o.y && y <= o.y + h); } function isPointInImage(imgObj, x, y) { const w = imgObj.width * imgObj.scale; const h = imgObj.height * imgObj.scale; return (x >= imgObj.x && x <= imgObj.x + w && y >= imgObj.y && y <= imgObj.y + h); } canvas.addEventListener('mousedown', e => { const rect = canvas.getBoundingClientRect(); const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top; dragging = false; for (let i = objects.length - 1; i >= 0; i--) { if (isPointInText(objects[i], mouseX, mouseY)) { selectedType = 'text'; selectedIndex = i; dragOffsetX = mouseX - objects[i].x; dragOffsetY = mouseY - objects[i].y; dragging = true; needsRedraw = true; requestAnimationFrame(drawIfNeeded); return; } } for (let i = images.length - 1; i >= 0; i--) { if (isPointInImage(images[i], mouseX, mouseY)) { selectedType = 'image'; selectedIndex = i; dragOffsetX = mouseX - images[i].x; dragOffsetY = mouseY - images[i].y; dragging = true; needsRedraw = true; requestAnimationFrame(drawIfNeeded); return; } } selectedType = null; selectedIndex = -1; needsRedraw = true; requestAnimationFrame(drawIfNeeded); }); canvas.addEventListener('mousemove', e => { if (!dragging) return; const rect = canvas.getBoundingClientRect(); const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top; if (selectedType === 'text' && selectedIndex >= 0) { objects[selectedIndex].x = mouseX - dragOffsetX; objects[selectedIndex].y = mouseY - dragOffsetY; needsRedraw = true; } else if (selectedType === 'image' && selectedIndex >= 0) { images[selectedIndex].x = mouseX - dragOffsetX; images[selectedIndex].y = mouseY - dragOffsetY; needsRedraw = true; } requestAnimationFrame(drawIfNeeded); }); window.addEventListener('mouseup', () => { dragging = false; }); function drawIfNeeded() { if (needsRedraw) { draw(); needsRedraw = false; } } function downloadCanvas(format) { const tmpCanvas = document.createElement('canvas'); tmpCanvas.width = 1920; tmpCanvas.height = 768; const tmpCtx = tmpCanvas.getContext('2d'); tmpCtx.save(); if (bgImage) { if (document.getElementById('bgRadius').checked) { const r = 30; tmpCtx.beginPath(); tmpCtx.moveTo(r, 0); tmpCtx.lineTo(1920 - r, 0); tmpCtx.quadraticCurveTo(1920, 0, 1920, r); tmpCtx.lineTo(1920, 768 - r); tmpCtx.quadraticCurveTo(1920, 768, 1920 - r, 768); tmpCtx.lineTo(r, 768); tmpCtx.quadraticCurveTo(0, 768, 0, 768 - r); tmpCtx.lineTo(0, r); tmpCtx.quadraticCurveTo(0, 0, r, 0); tmpCtx.closePath(); tmpCtx.clip(); } tmpCtx.drawImage(bgImage, 0, 0, 1920, 768); } else { tmpCtx.fillStyle = '#222'; tmpCtx.fillRect(0, 0, 1920, 768); } tmpCtx.restore(); images.forEach(imgObj => { tmpCtx.save(); tmpCtx.translate(imgObj.x + imgObj.width * imgObj.scale / 2, imgObj.y + imgObj.height * imgObj.scale / 2); tmpCtx.rotate(imgObj.rotation * Math.PI / 180); tmpCtx.drawImage(imgObj.img, -imgObj.width * imgObj.scale / 2, -imgObj.height * imgObj.scale / 2, imgObj.width * imgObj.scale, imgObj.height * imgObj.scale); tmpCtx.restore(); }); objects.forEach(o => { tmpCtx.save(); tmpCtx.translate(o.x, o.y); tmpCtx.rotate(o.rotation * Math.PI / 180); tmpCtx.font = (o.italic ? 'italic ' : '') + (o.bold ? 'bold ' : '') + o.fontSize + 'px ' + o.fontFamily; tmpCtx.textBaseline = 'top'; const displayText = o.uppercase ? o.text.toUpperCase() : o.text; if (o.strokeWidth > 0) { tmpCtx.lineWidth = o.strokeWidth; tmpCtx.strokeStyle = o.strokeColor; tmpCtx.strokeText(displayText, 0, 0); } tmpCtx.fillStyle = o.color; tmpCtx.fillText(displayText, 0, 0); tmpCtx.restore(); }); const type = (format === 'jpeg') ? 'image/jpeg' : 'image/png'; const link = document.createElement('a'); link.download = (format === 'jpeg' ? 'image.jpg' : 'image.png'); link.href = tmpCanvas.toDataURL(type); link.click(); } document.getElementById('saveJPG').onclick = () => downloadCanvas('jpeg'); document.getElementById('savePNG').onclick = () => downloadCanvas('png'); requestAnimationFrame(drawIfNeeded); </script> </body> </html>
